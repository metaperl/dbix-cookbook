=head1 NAME

DBIx::Cookbook::Doc::Searching - Recipes for querying databases

=head1 SEARCHING

=head2 Paged results

When you expect a large number of results, you can ask L<DBIx::Class> for a
paged resultset, which will fetch only a defined number of records at a time:

  my $rs = $schema->resultset('Artist')->search(
    undef,
    {
      page => 1,  # page to return (defaults to 1)
      rows => 10, # number of results per page
    },
  );

  return $rs->all(); # all records for page 1

  return $rs->page(2); # records for page 2

You can get a L<Data::Page> object for the resultset (suitable for use
in e.g. a template) using the C<pager> method:

  return $rs->pager();

=head2 Complex WHERE clauses

Sometimes you need to formulate a query using specific operators:

  my @albums = $schema->resultset('Album')->search({
    artist => { 'like', '%Lamb%' },
    title  => { 'like', '%Fear of Fours%' },
  });

This results in something like the following C<WHERE> clause:

  WHERE artist LIKE ? AND title LIKE ?

And the following bind values for the placeholders: C<'%Lamb%'>, C<'%Fear of
Fours%'>.

Other queries might require slightly more complex logic:

  my @albums = $schema->resultset('Album')->search({
    -or => [
      -and => [
        artist => { 'like', '%Smashing Pumpkins%' },
        title  => 'Siamese Dream',
      ],
      artist => 'Starchildren',
    ],
  });

This results in the following C<WHERE> clause:

  WHERE ( artist LIKE '%Smashing Pumpkins%' AND title = 'Siamese Dream' )
    OR artist = 'Starchildren'

For more information on generating complex queries, see
L<SQL::Abstract/WHERE CLAUSES>.

=head2 Retrieve one and only one row from a resultset

Sometimes you need only the first "top" row of a resultset. While this
can be easily done with L<< $rs->first|DBIx::Class::ResultSet/first
>>, it is suboptimal, as a full blown cursor for the resultset will be
created and then immediately destroyed after fetching the first row
object.  L<< $rs->single|DBIx::Class::ResultSet/single >> is designed
specifically for this case - it will grab the first returned result
without even instantiating a cursor.

Before replacing all your calls to C<first()> with C<single()> please observe the
following CAVEATS:

=over

=item *

While single() takes a search condition just like search() does, it does
_not_ accept search attributes. However one can always chain a single() to
a search():

  my $top_cd = $cd_rs->search({}, { order_by => 'rating' })->single;


=item *

Since single() is the engine behind find(), it is designed to fetch a
single row per database query. Thus a warning will be issued when the
underlying SELECT returns more than one row. Sometimes however this usage
is valid: i.e. we have an arbitrary number of cd's but only one of them is
at the top of the charts at any given time. If you know what you are doing,
you can silence the warning by explicitly limiting the resultset size:

  my $top_cd = $cd_rs->search ({}, { order_by => 'rating', rows => 1 })->single;

=back

=head2 Arbitrary SQL through a custom ResultSource

Sometimes you have to run arbitrary SQL because your query is too complex
(e.g. it contains Unions, Sub-Selects, Stored Procedures, etc.) or has to
be optimized for your database in a special way, but you still want to
get the results as a L<DBIx::Class::ResultSet>.

This is accomplished by defining a
L<ResultSource::View|DBIx::Class::ResultSource::View> for your query,
almost like you would define a regular ResultSource.

  package My::Schema::Result::UserFriendsComplex;
  use strict;
  use warnings;
  use base qw/DBIx::Class::Core/;

  __PACKAGE__->table_class('DBIx::Class::ResultSource::View');

  # ->table, ->add_columns, etc.

  # do not attempt to deploy() this view
  __PACKAGE__->result_source_instance->is_virtual(1);

  __PACKAGE__->result_source_instance->view_definition(q[
    SELECT u.* FROM user u
    INNER JOIN user_friends f ON u.id = f.user_id
    WHERE f.friend_user_id = ?
    UNION
    SELECT u.* FROM user u
    INNER JOIN user_friends f ON u.id = f.friend_user_id
    WHERE f.user_id = ?
  ]);

Next, you can execute your complex query using bind parameters like this:

  my $friends = $schema->resultset( 'UserFriendsComplex' )->search( {},
    {
      bind  => [ 12345, 12345 ]
    }
  );

... and you'll get back a perfect L<DBIx::Class::ResultSet> (except, of course,
that you cannot modify the rows it contains, e.g. cannot call L</update>,
L</delete>, ...  on it).

Note that you cannot have bind parameters unless is_virtual is set to true.

=over

=item * NOTE

If you're using the old deprecated C<< $rsrc_instance->name(\'( SELECT ...') >>
method for custom SQL execution, you are highly encouraged to update your code 
to use a virtual view as above. If you do not want to change your code, and just
want to suppress the deprecation warning when you call
L<DBIx::Class::Schema/deploy>, add this line to your source definition, so that
C<deploy> will exclude this "table":

  sub sqlt_deploy_hook { $_[1]->schema->drop_table ($_[1]) }

=back

=head2 Using specific columns

When you only want specific columns from a table, you can use
C<columns> to specify which ones you need. This is useful to avoid
loading columns with large amounts of data that you aren't about to
use anyway:

  my $rs = $schema->resultset('Artist')->search(
    undef,
    {
      columns => [qw/ name /]
    }
  );

  # Equivalent SQL:
  # SELECT artist.name FROM artist

This is a shortcut for C<select> and C<as>, see below. C<columns>
cannot be used together with C<select> and C<as>.

=head2 Using database functions or stored procedures

The combination of C<select> and C<as> can be used to return the result of a
database function or stored procedure as a column value. You use C<select> to
specify the source for your column value (e.g. a column name, function, or
stored procedure name). You then use C<as> to set the column name you will use
to access the returned value:

  my $rs = $schema->resultset('Artist')->search(
    {},
    {
      select => [ 'name', { LENGTH => 'name' } ],
      as     => [qw/ name name_length /],
    }
  );

  # Equivalent SQL:
  # SELECT name name, LENGTH( name )
  # FROM artist

Note that the C<as> attribute B<has absolutely nothing to do> with the SQL
syntax C< SELECT foo AS bar > (see the documentation in 
L<DBIx::Class::ResultSet/ATTRIBUTES>). You can control the C<AS> part of the
generated SQL via the C<-as> field attribute as follows:

  my $rs = $schema->resultset('Artist')->search(
    {},
    {
      join => 'cds',
      distinct => 1,
      '+select' => [ { count => 'cds.cdid', -as => 'amount_of_cds' } ],
      '+as' => [qw/num_cds/],
      order_by => { -desc => 'amount_of_cds' },
    }
  );

  # Equivalent SQL
  # SELECT me.artistid, me.name, me.rank, me.charfield, COUNT( cds.cdid ) AS amount_of_cds 
  #   FROM artist me LEFT JOIN cd cds ON cds.artist = me.artistid 
  # GROUP BY me.artistid, me.name, me.rank, me.charfield 
  # ORDER BY amount_of_cds DESC 


If your alias exists as a column in your base class (i.e. it was added with
L<add_columns|DBIx::Class::ResultSource/add_columns>), you just access it as
normal. Our C<Artist> class has a C<name> column, so we just use the C<name>
accessor:

  my $artist = $rs->first();
  my $name = $artist->name();

If on the other hand the alias does not correspond to an existing column, you
have to fetch the value using the C<get_column> accessor:

  my $name_length = $artist->get_column('name_length');

If you don't like using C<get_column>, you can always create an accessor for
any of your aliases using either of these:

  # Define accessor manually:
  sub name_length { shift->get_column('name_length'); }

  # Or use DBIx::Class::AccessorGroup:
  __PACKAGE__->mk_group_accessors('column' => 'name_length');

See also L</Using SQL functions on the left hand side of a comparison>.

=head2 SELECT DISTINCT with multiple columns

  my $rs = $schema->resultset('Artist')->search(
    {},
    {
      columns => [ qw/artist_id name rank/ ],
      distinct => 1
    }
  );

  my $rs = $schema->resultset('Artist')->search(
    {},
    {
      columns => [ qw/artist_id name rank/ ],
      group_by => [ qw/artist_id name rank/ ],
    }
  );

  # Equivalent SQL:
  # SELECT me.artist_id, me.name, me.rank
  # FROM artist me
  # GROUP BY artist_id, name, rank

=head2 SELECT COUNT(DISTINCT colname)

  my $rs = $schema->resultset('Artist')->search(
    {},
    {
      columns => [ qw/name/ ],
      distinct => 1
    }
  );

  my $rs = $schema->resultset('Artist')->search(
    {},
    {
      columns => [ qw/name/ ],
      group_by => [ qw/name/ ],
    }
  );

  my $count = $rs->count;

  # Equivalent SQL:
  # SELECT COUNT( * ) FROM (SELECT me.name FROM artist me GROUP BY me.name) count_subq:

=head2 Grouping results

L<DBIx::Class> supports C<GROUP BY> as follows:

  my $rs = $schema->resultset('Artist')->search(
    {},
    {
      join     => [qw/ cds /],
      select   => [ 'name', { count => 'cds.id' } ],
      as       => [qw/ name cd_count /],
      group_by => [qw/ name /]
    }
  );

  # Equivalent SQL:
  # SELECT name, COUNT( cd.id ) FROM artist
  # LEFT JOIN cd ON artist.id = cd.artist
  # GROUP BY name

Please see L<DBIx::Class::ResultSet/ATTRIBUTES> documentation if you
are in any way unsure about the use of the attributes above (C< join
>, C< select >, C< as > and C< group_by >).

=head2 Subqueries

You can write subqueries relatively easily in DBIC.

  my $inside_rs = $schema->resultset('Artist')->search({
    name => [ 'Billy Joel', 'Brittany Spears' ],
  });

  my $rs = $schema->resultset('CD')->search({
    artist_id => { 'IN' => $inside_rs->get_column('id')->as_query },
  });

The usual operators ( =, !=, IN, NOT IN, etc.) are supported.

B<NOTE>: You have to explicitly use '=' when doing an equality comparison.
The following will B<not> work:

  my $rs = $schema->resultset('CD')->search({
    artist_id => $inside_rs->get_column('id')->as_query,  # does NOT work
  });

=head3 Support

Subqueries are supported in the where clause (first hashref), and in the
from, select, and +select attributes.

=head3 Correlated subqueries

  my $cdrs = $schema->resultset('CD');
  my $rs = $cdrs->search({
    year => {
      '=' => $cdrs->search(
        { artist_id => { '=' => \'me.artist_id' } },
        { alias => 'inner' }
      )->get_column('year')->max_rs->as_query,
    },
  });

That creates the following SQL:

  SELECT me.cdid, me.artist, me.title, me.year, me.genreid, me.single_track
    FROM cd me
   WHERE year = (
      SELECT MAX(inner.year)
        FROM cd inner
       WHERE artist_id = me.artist_id
      )

=head2 Predefined searches

You can define frequently used searches as methods by subclassing
L<DBIx::Class::ResultSet>:

  package My::DBIC::ResultSet::CD;
  use strict;
  use warnings;
  use base 'DBIx::Class::ResultSet';

  sub search_cds_ordered {
      my ($self) = @_;

      return $self->search(
          {},
          { order_by => 'name DESC' },
      );
  }

  1;

If you're using L<DBIx::Class::Schema/load_namespaces>, simply place the file
into the C<ResultSet> directory next to your C<Result> directory, and it will
be automatically loaded.

If however you are still using L<DBIx::Class::Schema/load_classes>, first tell
DBIx::Class to create an instance of the ResultSet class for you, in your
My::DBIC::Schema::CD class:

  # class definition as normal
  use base 'DBIx::Class::Core';
  __PACKAGE__->table('cd');

  # tell DBIC to use the custom ResultSet class
  __PACKAGE__->resultset_class('My::DBIC::ResultSet::CD');

Note that C<resultset_class> must be called after C<load_components> and C<table>, or you will get errors about missing methods.

Then call your new method in your code:

   my $ordered_cds = $schema->resultset('CD')->search_cds_ordered();

=head2 Using SQL functions on the left hand side of a comparison

Using SQL functions on the left hand side of a comparison is generally not a
good idea since it requires a scan of the entire table. (Unless your RDBMS
supports indexes on expressions - including return values of functions - and
you create an index on the return value of the function in question.) However,
it can be accomplished with C<DBIx::Class> when necessary.

Your approach for doing so will depend on whether you have turned
quoting on via the C<quote_char> and C<name_sep> attributes. If you
explicitly defined C<quote_char> and C<name_sep> in your
C<connect_info> (see L<DBIx::Class::Storage::DBI/"connect_info">) then
you are using quoting, otherwise not.

If you do not have quoting on, simply include the function in your search
specification as you would any column:

  $rs->search({ 'YEAR(date_of_birth)' => 1979 });

With quoting on, or for a more portable solution, use literal SQL values with
placeholders:

  $rs->search(\[ 'YEAR(date_of_birth) = ?', [ plain_value => 1979 ] ]);

  # Equivalent SQL:
  # SELECT * FROM employee WHERE YEAR(date_of_birth) = ?

  $rs->search({
    name => 'Bob',
    -nest => \[ 'YEAR(date_of_birth) = ?', [ plain_value => 1979 ] ],
  });

  # Equivalent SQL:
  # SELECT * FROM employee WHERE name = ? AND YEAR(date_of_birth) = ?

Note: the C<plain_value> string in the C<< [ plain_value => 1979 ] >> part
should be either the same as the name of the column (do this if the type of the
return value of the function is the same as the type of the column) or
otherwise it's essentially a dummy string currently (use C<plain_value> as a
habit). It is used by L<DBIx::Class> to handle special column types.

See also L<SQL::Abstract/Literal SQL with placeholders and bind values
(subqueries)>.

